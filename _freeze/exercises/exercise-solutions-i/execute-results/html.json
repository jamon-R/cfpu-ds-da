{
  "hash": "7a9d748d3b96ad45e99c756a13b11535",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Exercises I\"\nsubtitle: \"Data Science and Data Analytics\"\nauthor: \"Julian Amon, PhD\"\ndate: \"March 21, 2025\"\ndate-format: long\nformat: html\nhighlight-style: arrow\nexecute: \n  warning: true\n  echo: true\n  eval: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n# The essentials of R programming\n\n\n\n\n\n\n\n\n\n\n1.  What is the sum of the first 100 positive integers? The formula for the sum of integers 1 through $n$ is $n(n+1)/2$. Define $n = 100$ and then use R to compute the sum of 1 through 100 using the formula. What is the sum?\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    n <- 100\n    n*(n+1)/2\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 5050\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n2.  Now use the same formula to compute the sum of the integers from 1 through 1000.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    n <- 1000\n    n*(n+1)/2\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 500500\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n3.  Choose any positive number and assign it to a variable named `x`. Then perform the following steps all in one line of R code:\n    -   Add 2 to `x`.\n    -   Multiply the result by 3.\n    -   Subtract 6 from the answer.\n    -   Divide what you get by 3.\n    -   Compute the logarithm in base 2 of the number you get in Step 4.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- 2\n    log((((x + 2) * 3) - 6)/3, base = 2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n4.  Now, write a function called `f` that performs the five steps outlined in exercise 3 for any given input `x`.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    f <- function(x) return(log((((x + 2) * 3) - 6)/3, base = 2))\n    f(2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n5.  Assign the value 3 to a variable named `x`, the value 4 to a variable named `y` and the value 5 to a variable named `z`. `x`, `y` and `z` form what is a called a [Pythagorean Triple](https://en.wikipedia.org/wiki/Pythagorean_triple), i.e. they are integers that satisfy the Pythagoras Theorem $x^2 + y^2 = z^2$. Verify that this is true with R.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- 3\n    y <- 4\n    z <- 5\n    z^2 == x^2 + y^2\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] TRUE\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n6.  Simulate 100 flips of a fair coin. Hint: use the function `sample` in conjunction with a character vector indicating the possible outcomes of a coin flip (i.e. \"heads\" and \"tails\"). Call the function multiple times to see that the outcome appears random.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sample(c(\"heads\", \"tails\"), 100, replace = TRUE)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n      [1] \"heads\" \"tails\" \"heads\" \"heads\" \"tails\" \"tails\" \"tails\" \"heads\" \"heads\"\n     [10] \"heads\" \"heads\" \"heads\" \"heads\" \"heads\" \"tails\" \"heads\" \"tails\" \"tails\"\n     [19] \"heads\" \"heads\" \"tails\" \"heads\" \"tails\" \"tails\" \"heads\" \"heads\" \"heads\"\n     [28] \"tails\" \"heads\" \"heads\" \"tails\" \"tails\" \"heads\" \"heads\" \"heads\" \"heads\"\n     [37] \"heads\" \"heads\" \"heads\" \"tails\" \"tails\" \"tails\" \"tails\" \"tails\" \"heads\"\n     [46] \"tails\" \"heads\" \"heads\" \"heads\" \"tails\" \"heads\" \"tails\" \"heads\" \"tails\"\n     [55] \"tails\" \"heads\" \"tails\" \"heads\" \"heads\" \"tails\" \"tails\" \"tails\" \"tails\"\n     [64] \"heads\" \"heads\" \"heads\" \"tails\" \"heads\" \"heads\" \"tails\" \"heads\" \"heads\"\n     [73] \"tails\" \"tails\" \"tails\" \"tails\" \"tails\" \"heads\" \"tails\" \"heads\" \"tails\"\n     [82] \"heads\" \"tails\" \"heads\" \"heads\" \"heads\" \"tails\" \"tails\" \"heads\" \"tails\"\n     [91] \"tails\" \"tails\" \"tails\" \"heads\" \"tails\" \"heads\" \"heads\" \"tails\" \"tails\"\n    [100] \"tails\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n7.  What are the data types of the following objects? If in doubt, determine them using `typeof`.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x1 <- 10\n    x2 <- \"10\"\n    x3 <- (10 > 10)\n    x4 <- \"ten\"\n    x5 <- 10L\n    ```\n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    typeof(x1)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"double\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    typeof(x2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"character\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    typeof(x3)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"logical\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    typeof(x4)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"character\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    typeof(x5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"integer\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n8.  In the following code block, try to predict the output of each individual line. Then run the code in R to see if you were right.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- 5 > 3\n    is.logical(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] TRUE\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    is.logical(!x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] TRUE\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    !is.logical(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] FALSE\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    !is.logical(!x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] FALSE\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n9.  Create a vector called `some_thing` containing your first name, your age and whether or not you like ice cream (TRUE vs. FALSE). Can you predict the data type of the resulting vector? Verify using R.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    some_thing <- c(\"James\", 24, TRUE)\n    typeof(some_thing)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"character\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n10. Using the functions `seq` and `rep` as needed, create the vectors\n    \n    `0 0 0 0 0 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4`\n    \n    and\n    \n    `1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5`\n    \n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    rep(seq(0, 4), each = 5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n     [1] 0 0 0 0 0 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    rep(seq(1, 5), 5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n     [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n11. Using the functions `seq` and `rep` as needed, create the vector\n    \n    `1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9`\n    \n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    rep(seq(0, 4), each = 5) + rep(seq(1, 5), 5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n     [1] 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n12. Write a function which outputs whether a given number is positive or negative.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    f <- function(x){\n      if(x < 0){\n        return(\"negative\")\n      } else if(x > 0){\n        return(\"positive\")\n      } else {\n        return(\"zero\")\n      }\n    }\n    f(-4.2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"negative\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    f(2.34)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"positive\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    f(0)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"zero\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n13. Write a function which, for a given natural number $n$, returns a sequence where each $i \\leq n$ is repeated $i$ times, in ascending order. For example, for $n = 4$, the function should return `1 2 2 3 3 3 4 4 4 4`.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    f <- function(n){\n      return(rep(1:n, 1:n))\n    }\n    f(4)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n     [1] 1 2 2 3 3 3 4 4 4 4\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    f(8)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n     [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n14. Write a function which outputs which of two given character strings is shorter. Hint: use the function `nchar`.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    select_shorter <- function(c1, c2){\n      n1 <- nchar(c1)\n      n2 <- nchar(c2)\n      if(n1 < n2){\n        return(c1)\n      } else if(n1 > n2){\n        return(c2)\n      } else {\n        return(\"Equal length\")\n      }\n    }\n    select_shorter(\"Hello\", \"Hi\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"Hi\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n15. Write a function which takes three numbers as arguments and returns the sum of the squares of the two larger numbers.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    f <- function(x, y, z){\n      nums <- c(x, y, z)\n      return(sum(nums[-which.min(nums)]^2))\n    }\n    f(3, 4, 5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 41\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n16. Write a function that for a given character vector, extracts all those that contain only lower-case letters, i.e. for the input `c(\"a\", \"ab, \"abC\")`, it should return `\"a\" \"ab\"`. Hint: use the function `tolower`.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    f <- function(x){\n      return(x[tolower(x) == x])\n    }\n    f(c(\"a\", \"ab\", \"abC\"))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"a\"  \"ab\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n17. Create two vectors, one called `heights` containing the values 176, 178 and 156, and another called `names` containing the values \"Anna\", \"Jakob\" and \"Lisa\". Use `cbind` to combine these vectors into a matrix called `m`. What will be the data type of that matrix and why? Why is a matrix not a good data structure to store `heights` and `names` together? What would be a better alternative?\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    heights <- c(176, 178, 156)\n    names <- c(\"Anna\", \"Jakob\", \"Lisa\")\n    m <- cbind(heights, names)\n    m\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         heights names  \n    [1,] \"176\"   \"Anna\" \n    [2,] \"178\"   \"Jakob\"\n    [3,] \"156\"   \"Lisa\" \n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    typeof(m)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"character\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # Character matrix due to coercion. All elements have to be of the same type.\n    # Not a good data structure because we cannot perform numeric operations on\n    # character strings:\n    sum(m[,1])\n    ```\n    \n    ::: {.cell-output .cell-output-error}\n    \n    ```\n    Error in sum(m[, 1]): ungültiger 'type' (character) des Argumentes\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # Use a data.frame instead:\n    df <- data.frame(heights = heights, names = names)\n    sum(df$heights)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 510\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n18. Create three vectors, one called `state` containing the values \"Vorarlberg\", \"Tyrol\", \"Salzburg\", \"Upper Austria\", \"Lower Austria\", \"Carinthia\", \"Styria\", \"Burgenland\" and \"Vienna\", one called `population` containing the values 402, 764, 561, 1505, 1699, 565, 1253, 298 and 1932, and one called `area` containing the values 2602, 12648, 7155, 11983, 19180, 9537, 16399, 3965 and 415. Create a list whose elements are these three vectors. Name the list elements in accordance with the variable names. Turn this list into a `data.frame` called `state_df`.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    state <- c(\"Vorarlberg\", \"Tyrol\", \"Salzburg\", \"Upper Austria\", \"Lower Austria\",\n               \"Carinthia\", \"Styria\", \"Burgenland\", \"Vienna\")\n    population <- c(402, 764, 561, 1505, 1699, 565, 1253, 298, 1932)\n    area <- c(2602, 12648, 7155, 11983, 19180, 9537, 16399, 3965, 415)\n    state_list <- list(state, population, area)\n    names(state_list) <- c(\"state\", \"population\", \"area\")\n    state_df <- data.frame(state_list)\n    state_df\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n              state population  area\n    1    Vorarlberg        402  2602\n    2         Tyrol        764 12648\n    3      Salzburg        561  7155\n    4 Upper Austria       1505 11983\n    5 Lower Austria       1699 19180\n    6     Carinthia        565  9537\n    7        Styria       1253 16399\n    8    Burgenland        298  3965\n    9        Vienna       1932   415\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n19. The `data.frame` from exercise 18 contains the population (in thousands) and the area (in square kilometres) of all nine Austrian federal states. Use it to perform the following tasks:\n    -   Obtain the population of Upper Austria using numerical indexing of the `data.frame`.\n    -   Obtain the area of Carinthia using logical indexing for the row and character-based indexing for the column of the `data.frame`.\n    -   Add a new column called `density` to the `data.frame`, which holds the population densities of the nine states in number of people per square kilometre.\n    -   Use the `$` operator and numerical subsetting to get the population density of Vienna.\n    -   Obtain the row of the `data.frame` that holds all information of the state with the lowest population density.\n    -   Use the `order` function to sort the `data.frame` by population in descending order.\n    -   Set the rownames of the `data.frame` equal to the `state` variable and then remove this variable from the `data.frame`.\n    \n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # Population of Upper Austria\n    state_df[4,2]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1505\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # Area of Carinthia\n    state_df[state_df$state == \"Carinthia\", \"area\"]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 9537\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # Add density column\n    state_df$density <- state_df$population*1000/state_df$area\n    # Population density of Vienna:\n    state_df$density[9]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 4655.422\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # State with lowest population density:\n    state_df[which.min(state_df$density), ]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n          state population area  density\n    6 Carinthia        565 9537 59.24295\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # Sort by population in descending order:\n    state_df <- state_df[order(state_df$population, decreasing = TRUE), ]\n    # Set state as rownames and then remove it:\n    rownames(state_df) <- state_df$state\n    state_df <- state_df[,-1]\n    state_df\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n                  population  area    density\n    Vienna              1932   415 4655.42169\n    Lower Austria       1699 19180   88.58186\n    Upper Austria       1505 11983  125.59459\n    Styria              1253 16399   76.40710\n    Tyrol                764 12648   60.40481\n    Carinthia            565  9537   59.24295\n    Salzburg             561  7155   78.40671\n    Vorarlberg           402  2602  154.49654\n    Burgenland           298  3965   75.15763\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n20. Using `lapply` and the `data.frame` from the previous exercise, find the (unweighted) average population, area and population density of the nine Austrian federal states. Hint: use the function `mean`.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    lapply(state_df, mean)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    $population\n    [1] 997.6667\n    \n    $area\n    [1] 9320.444\n    \n    $density\n    [1] 597.0793\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n21. Write a function called `compute_s_n`, which, for a given $n$ computes the sum $S_n = 1^2 + 2^2 + 3^2 + \\ldots + n^2$. Report the value of the sum for $n = 10$.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    compute_s_n <- function(n){\n      sum((1:n)^2)\n    }\n    compute_s_n(10)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 385\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n22. Using the function `numeric`, instantiate an empty numeric vector called `s_n` of length 25. Now, using a `for` loop and the function `compute_s_n` from the previous exercise, store in `s_n` the results of $S_1, S_2, \\ldots, S_{25}$.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    s_n <- numeric(25)\n    for(i in seq_along(s_n)){\n      s_n[i] <- compute_s_n(i)\n    }\n    s_n\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n     [1]    1    5   14   30   55   91  140  204  285  385  506  650  819 1015 1240\n    [16] 1496 1785 2109 2470 2870 3311 3795 4324 4900 5525\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n23. Repeat exercise 22 using a `while` loop instead.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    s_n <- numeric(25)\n    i <- 1\n    while(i <= 25){\n      s_n[i] <- compute_s_n(i)\n      i <- i + 1\n    }\n    s_n\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n     [1]    1    5   14   30   55   91  140  204  285  385  506  650  819 1015 1240\n    [16] 1496 1785 2109 2470 2870 3311 3795 4324 4900 5525\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n24. Repeat exercise 22 using `lapply` instead. Hint: to turn the list output of `lapply` into an atomic vector, have a look at the function `unlist`.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    unlist(lapply(1:25, compute_s_n))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n     [1]    1    5   14   30   55   91  140  204  285  385  506  650  819 1015 1240\n    [16] 1496 1785 2109 2470 2870 3311 3795 4324 4900 5525\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n\n\n20. Write a function called `find_weekday`, which takes as input a character string representing a date in `DD.MM.YYYY` format, and serves as output the weekday that this particular date was. Use it to find out on which day of the week you were born.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    find_weekday <- function(datestring){\n      format(as.Date(datestring, \"%d.%m.%Y\"), \"%A\")\n    }\n    find_weekday(\"16.04.1998\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"Thursday\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n\n\n\n21. Install and load the package `ggplot2`.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    install.packages(\"ggplot2\")\n    library(ggplot2)\n    ```\n    :::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}