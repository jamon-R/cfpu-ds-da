{
  "hash": "54ddb5a45e4ca9f834edf038e337420e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Science and Data Analytics\"\nsubtitle: \"The Data Science Workflow II -- Visualize\"\nauthor: \"Julian Amon, PhD\"\ndate: \"April 4, 2025\"\ndate-format: long\ninstitute: Charlotte Fresenius PrivatuniversitÃ¤t\nfooter: \"Data Science and Data Analytics -- The Data Science Workflow II\"\nformat:\n  revealjs:\n    theme:\n      - default\n      - slides.scss\n    width: 1350\n    height: 900\n    slide-number: true\n    logo: img/UOS_Logo.jpg\n    fig-width: 14\n    controls: true\n    embed-resources: true\nhighlight-style: arrow\nexecute: \n  warning: true\n  echo: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n# First steps in data visualization\n\n\n\n\n\n\n\n## The Data Science workflow -- Visualize\n\n![](img/data-science-cycle.004.png){fig-align=\"center\"}\n\n## Why even look at data?\n\n-   Given the multitude of ways we can describe data numerically (using descriptive statistics), why do we even bother to present data visually?\n-   The answer is that descriptive statistics can never tell us the full story about our data. Consider the following artificial data set from Anscombe (1973):\n\n\n\n::: {.cell}\n\n:::\n\n\n\n. . .\n\n:::::: columns\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\nIt is a collection of four data sets, each with 11 observations for variables `x` and `y`. Here is the first 2 rows of each:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n   data_id  x     y\n1        1 10  8.04\n2        1  8  6.95\n12       2 10  9.14\n13       2  8  8.14\n24       3  8  6.77\n25       3 13 12.74\n36       4  8  7.71\n37       4  8  8.84\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"49%\"}\nAll these four data sets have: same mean and SD in `x` and `y`, and same correlation between them:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  data_id mean_x  sd_x mean_y  sd_y   cor\n1       1      9 3.317  7.501 2.032 0.816\n2       2      9 3.317  7.501 2.032 0.816\n3       3      9 3.317  7.500 2.030 0.816\n4       4      9 3.317  7.501 2.031 0.817\n```\n\n\n:::\n:::\n\n\n\nSo, seems like these data sets should look pretty similar, right?\n:::\n::::::\n\n## Why even look at data?\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-5-1.png){width=1344}\n:::\n:::\n\n\n\n## Why even look at data?\n\n-   While this is an extreme, manufactured example, it does prove a point: visualizing data offers insight that the study of pure statistics does not.\n-   But that does not mean looking at data is all one needs to do:\n    -   Real data sets are often complicated and messy, displaying them graphically presents problems of its own.\n    -   The core problem of visualization is how to **map** relations between observations to visual representations in the plot, like shape, lines, colour, size, etc.\n    -   How to do this optimally for each given data set is subject to considerable debate. There is no simple recipe to follow.\n-   Fortunately, however, there is software that provides a lot of support in our data visualization endeavours.\n\n## Data visualization in R\n\n::: {.callout-note appearance=\"minimal\"}\n\"The simple graph has brought more information to the data analyst's mind than any other device.\"\n\nJohn Tukey (Statistician, 1915 - 2000)\n:::\n\n-   There are many tools for visualizing data. Of course, we use R ðŸ˜‰\n-   Even with R, there are many approaches / systems / packages for creating data visualizations. By far the most common one is the package `ggplot2`.\n-   The **gg** in `ggplot2` stands for the **grammar of graphics**, which is a coherent system for describing and building graphs developed by statistician Leland Wilkinson in his aptly named 2005 book.\n-   As we will see in great detail, this system constructs plots in layers that are built on top of one another in an additive fashion.\n\n## The grammar of graphics\n\n::: slightlysmall\nThe grammar is a set of rules for producing graphics from data, taking pieces of data and mapping them to **geometric objects** (like points and lines) that have **aesthetic attributes** (like position, colour and size), together with further rules for transforming the data if needed, adjusting scales, adapting coordinate system and themes.\n:::\n\n:::::: columns\n::: {.column width=\"10%\"}\n:::\n\n::: {.column width=\"33%\"}\n![](img/grammar_of_graphics_book.jpeg){width=\"60%\"}\n:::\n\n::: {.column width=\"54%\"}\n![](img/grammar_of_graphics.png){width=\"75%\"}\n:::\n::::::\n\n::: {.callout-note appearance=\"simple\"}\n**Note**: a grammar limits the structure of what you can say, but it does not automatically make what you say meaningful, i.e. your code just being \"grammatically\" correct does not make the resulting plot sensible.\n:::\n\n\n## An introductory example -- Palmer penguins\n\nLet's see an example of how this works with `ggplot2` in practice.\n\n. . .\n\n-   The data set we will use for our first `ggplot` is the [**palmerpenguins**](https://education.rstudio.com/blog/2020/07/palmerpenguins-cran/) data set that can be obtained from CRAN in a package that bears exactly that name.\n-   It contains size measurements, clutch observations, and blood isotope ratios for **three penguin species** observed on three islands in the Palmer Archipelago, Antarctica over a study period of three years.\n\n![](img/palmer_penguins.jpg){fig-align=\"center\" width=\"50%\"}\n\n\n## An introductory example -- Palmer penguins\n\nMake sure the required packages `palmerpenguins` and `ggplot2` are installed. Then we can load them and start by inspecting the data set:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\nlibrary(ggplot2)\n\npenguins <- as.data.frame(penguins)\nhead(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   <NA> 2007\n5 female 2007\n6   male 2007\n```\n\n\n:::\n:::\n\n\n\n![](img/penguins_beak.png){.absolute top=\"550\" left=\"200\" width=\"35%\"}\n\n::::: columns\n::: {.column width=\"90%}\n\n:::\n\n::: {.column width=\"10%\"}\n::: xsmall\nArtwork by [@allison_horst](https://allisonhorst.com/)\n:::\n:::\n:::::\n\n\n## An introductory example -- Palmer penguins\n\nAs zoologists, we might be interested in the following questions about the different types of Palmer penguins:\n\n-   Do penguins with longer flippers weigh more or less than penguins with shorter flippers?\n-   What does the relationship between **flipper length** and **body mass** look like? Is it positive? Negative? Linear? Non-linear?\n-   Does the relationship vary by the species of the penguin? How about by the island where the penguin lives?\n\nLet's answer all of these questions using a single visualization.\n\n\n## An introductory example -- Ultimate goal\n\nUltimately, we want to create the following plot:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-7-1.png){width=1344}\n:::\n:::\n\n\n\n\n## First step -- Telling ggplot about our data set\n\nLet's recreate this plot step-by-step.\n\n. . .\n\nWith `ggplot2`, we begin a plot with the function `ggplot`. Its first argument is the dataset to use in the graph.\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins)\n```\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-8-1.png){width=1344}\n:::\n:::\n\n\n:::\n:::\n\n. . .\n\nFor now, we have not told `ggplot` how to visualize the data, so we only have an empty canvas. Now, we will \"paint\" onto this canvas in layers.\n\n\n## Second step -- Specifying aesthetic mappings\n\n::: slightlysmall\nThe second argument of `ggplot` is called `mapping`. It defines how variables in our data set are **mapped** to visual properties (**aesthetics**) of our plot. This argument is always defined in the `aes` function, and the `x` and `y` arguments of `aes` specify which variables to map to the x- and y-axes. We want flipper length on the `x` and body mass on the `y` axis.\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2-3\"}\nggplot(data = penguins,\n       mapping = aes(x = flipper_length_mm,\n                     y = body_mass_g))\n```\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-9-1.png){width=1344}\n:::\n:::\n\n\n:::\n:::\n\n. . .\n\n::: slightlysmall\nNow, our empty canvas has more structure: x- and y-axis have a range, ticks and labels. But the penguins themselves are not yet on the plot.\n:::\n\n\n## Third step -- Additively layer on geoms\n\n::: slightlysmall\nThis is because we have not yet articulated, in our code, **how** to represent the observations from our data frame on our plot. To do so, we need a **geom**, a geometrical object used for data representation. In the example, we want our data represented by points, so we use `geom_point`:\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"4\"}\nggplot(data = penguins,\n       mapping = aes(x = flipper_length_mm,\n                     y = body_mass_g)) +\n  geom_point()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-10-1.png){width=1344}\n:::\n:::\n\n\n:::\n:::\n\n. . .\n\n::: slightlysmall\nNow, we start to have an actual **scatter plot**. Note that R warns us about missing data points. We will suppress this warning in the plots to come.\n:::\n\n\n## A note about geoms\n\nIn **ggplot2**, geometric objects are made available with functions that start with `geom_`. People often describe plots by the type of geom that the plot uses, for example:\n\n-   Scatter plots use point geoms (`geom_point`) as we just saw.\n-   Bar charts use bar geoms (`geom_bar`)\n-   Line charts use line geoms (`geom_line`)\n-   Boxplots use boxplot geoms (`geom_boxplot`)\n-   ...\n\nWe layer a **geom** onto a ggplot literally in an **additive way**, i.e. by combining the two with a `+` sign. We will learn how to deal with many different geoms in this way.\n\n\n## Fourth step -- Adding aesthetics and layers\n\n::: slightlysmall\nDoes the relationship between flipper length and body mass differ by species? To answer this, let's represent species with different coloured points. To achieve this, we modify the **aesthetic** to additionally map species to colour:\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"4\"}\nggplot(data = penguins,\n       mapping = aes(x = flipper_length_mm,\n                     y = body_mass_g,\n                     color = species)) +\n  geom_point()\n```\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-11-1.png){width=1344}\n:::\n:::\n\n\n:::\n:::\n\n. . .\n\n::: slightlysmall\nIn mapping a categorical variable to the colour aesthetic, `ggplot2` automatically assigns a unique colour to each factor level (i.e. each species), a process known as **scaling**. `ggplot2` will also add a legend that explains which values correspond to which levels.\n:::\n\n\n## Fourth step -- Adding aesthetics and layers\n\n::: slightlysmall\nNow, let's add one more layer, a smooth curve displaying the relationship between body mass and flipper length. Since this is a new geometric object representing our data, we will add a new **geom**, namely `geom_smooth` based on a linear model (`lm`):\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"6\"}\nggplot(data = penguins,\n       mapping = aes(x = flipper_length_mm,\n                     y = body_mass_g,\n                     color = species)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n```\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-12-1.png){width=1344}\n:::\n:::\n\n\n:::\n:::\n\n. . .\n\n::: slightlysmall\nWe have successfully added lines, but this plot does not look like our ultimate goal. Instead of having only one line for the entire data set, we have separate lines for each of the three penguin species. What went wrong?\n:::\n\n\n## Fourth step -- Adding aesthetics and layers\n\n::: slightlysmall\nWhen aesthetics are defined in `ggplot()`, at the top level, theyâ€™re passed down to each of the subsequent **geom** layers of the plot. However, each geom function can also take a mapping argument, which allows for aesthetics at the local level. Here, we want point colours, but not lines separated by species, so we should specify `color = species` **locally** for `geom_point` only:\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"4\"}\nggplot(data = penguins,\n       mapping = aes(x = flipper_length_mm,\n                     y = body_mass_g)) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n```\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-13-1.png){width=1344}\n:::\n:::\n\n\n:::\n:::\n\n. . .\n\n::: slightlysmall\nWe are getting close to our ultimate goal... Some minor details are still missing though.\n:::\n\n\n## Fourth step -- Adding aesthetics and layers\n\n::: slightlysmall\nDue to differences in colour perception (e.g. colour blindness), it is generally not a good idea to represent information using only colours on a plot. Therefore, in addition to colour, we can also map `species` to the `shape` aesthetic:\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"5\"}\nggplot(data = penguins,\n       mapping = aes(x = flipper_length_mm,\n                     y = body_mass_g)) +\n  geom_point(mapping = aes(color = species,\n                           shape = species)) +\n  geom_smooth(method = \"lm\")\n```\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-14-1.png){width=1344}\n:::\n:::\n\n\n:::\n:::\n\n. . .\n\n::: slightlysmall\nNote that the legend is automatically updated to reflect the different shapes of the points as well.\n:::\n\n\n## Fifth step -- Adjust scales, labels, titles, ...\n\n::: slightlysmall\nThe \"clean-up\" work involves setting appropriate labels for title, subtitle, axes, and legend using the `labs` function and using the colourblind safe colour palette **scale_color_colorblind** from the `ggthemes` package (an extension of `ggplot2`):\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|3|4-5|6-7|8|9-14|1,15\"}\nlibrary(ggthemes)\n\nggplot(data = penguins,\n       mapping = aes(x = flipper_length_mm,\n                     y = body_mass_g)) +\n  geom_point(mapping = aes(color = species,\n                           shape = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(x = \"Flipper length (mm)\",\n       y = \"Body mass (g)\",\n       title = \"Body mass and flipper length\",\n       subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n       color = \"Species\",\n       shape = \"Species\") +\n  scale_color_colorblind()\n```\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-15-1.png){width=1344}\n:::\n:::\n\n\n:::\n:::\n\n. . .\n\n::: slightlysmall\nNow, we are done, we have built the plot of our ultimate goal step-by-step from the ground up. The example highlights the core principles of how `ggplot2` allows us to build nice-looking informative graphs with relatively little coding effort.\n:::\n\n\n\n# Basic types of plots with `ggplot2`\n\n## Steps in creating a plot with `ggplot2`\n\nConceptually, the steps we went through are the same for every plot created with `ggplot2`. Based on a **tidy** data set, we always proceed as follows:\n\n-   Telling `ggplot` about our data set.\n-   Specifying **aesthetic mappings**, i.e. what relationships we want to see and by what we want them represented.\n-   Additively layer on **geoms** as needed.\n-   Add and adapt aesthetics and layers until all relationships are displayed.\n-   Adjust scales, labels, titles, ...\n\n. . .\n\nThese steps are always the same. We will now only learn in greater detail about how to tell `ggplot` what to do by going through several examples of different data sets, aesthetic mappings, geoms and more. As with anything, the key to improvement is **LOTS** of trial and error...\n\n## Visualizing a numerical variable -- Histogram\n\nLet's say we want to visualize the distribution of body mass (in grams) across all penguins in the sample using a **histogram**. For this, we map the variable `body_mass_g` to `x` and use `geom_histogram`:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-16-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Visualizing a numerical variable -- Histogram\n\nA histogram divides the x-axis into equally spaced bins and then uses the height of a bar to display the number of observations that fall in each bin. `ggplot2` by default creates 30 such bins. We can control this by setting `bins` ourselves:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(bins = 15)\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-17-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Visualizing a numerical variable -- Histogram\n\nWe do not like the colour of this histogram. Previously, we set the `color` aesthetic, but here we do not want to **map** colour to a variable. Instead we want to **set** it to a specific colour. This we do in the **geom**, not in the `aes`:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(color = \"deepskyblue4\", bins = 15)\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-18-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Visualizing a numerical variable -- Histogram\n\nHm, this is not what we wanted... `ggplot` only coloured the border line of the bars. Turns out that if we want to **fill** the bars in a specific colour, we need to use the `fill` argument of the `geom_histogram` function:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(fill = \"deepskyblue4\", bins = 15)\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-19-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Visualizing a numerical variable -- Density plot\n\nAn alternative visualization for distributions of numerical variables is a **density plot**, which is a smoothed-out version of a histogram. To create one, we simply switch out our **geom** to `geom_density`:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_density()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-20-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Visualizing a numerical variable -- Density plot\n\nThat's a bit boring, let's change the colour again (both of the line itself using `color` and the area below the curve using `fill`):\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_density(color = \"deepskyblue4\", fill = \"deepskyblue4\")\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-21-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Visualizing a categorical variable -- Barplot\n\nA simple **bar chart** visualizes the (absolute or relative) frequencies of the levels of a categorical variable. While we could use `ggplot` directly on the data, it is generally preferable to compute frequencies explicitly ourselves, e.g. for species:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_freq <- as.data.frame(table(penguins$species))\nnames(species_freq)[1] <- \"species\"\n\n# As we have already computed frequencies, we have to tell the bar geom\n# that it should use the values as they are, i.e. use the \"identity\":\nggplot(species_freq, aes(x = species, y = Freq)) +\n  geom_bar(stat = \"identity\", fill = \"deepskyblue4\")\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-22-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Visualizing a categorical variable -- Barplot\n\nIf the variable has a nominal (and not ordinal) scale, then it is usually preferable to order the bars based on their frequency. For this, we have to **reorder** the factor levels for the species:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(species_freq, aes(x = reorder(species, Freq, decreasing = TRUE), y = Freq)) +\n  geom_bar(stat = \"identity\", fill = \"deepskyblue4\")\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-23-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Visualizing a categorical variable -- Barplot\n\nOften, we want the bars to be horizontal rather than vertical. To achieve this, we simply flip the axes using `coord_flip`. Additionally, we add nice axis labels:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(species_freq, aes(x = reorder(species, Freq, decreasing = TRUE), y = Freq)) +\n  geom_bar(stat = \"identity\", fill = \"deepskyblue4\") +\n  labs(x = \"Penguin Species\", y = \"Observed frequency\") +\n  coord_flip()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-24-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## A categorical and a numerical variable\n\nTo visualize the relationship between a categorical and a numerical variable, we can create **parallel boxplots**. For example, for the distribution of body weight by species, we could try:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) +\n  geom_boxplot()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-25-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## A categorical and a numerical variable\n\nAn alternative to boxplots are so-called **violin plots**. In their simplest form, these are rotated density plots of the numerical variable in each category mirrored to create a symmetric, \"violin-like\" object:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) +\n  geom_violin()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-26-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## A categorical and a numerical variable\n\nSince density plots can also mask certain aspects of the distribution of the data, it is often advisable to additionally plot the actual data points on top of the violin plots. We can do this by layering a **point geom** on top:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = species, y = body_mass_g, color = species)) +\n  geom_violin() +\n  geom_point()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-27-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## A categorical and a numerical variable\n\nIf we have a lot of points close together, then they overlap and it becomes impossible to tell their distribution. To avoid this, we can slightly perturb the points in the `x` direction. This is achieved by switching to `geom_jitter`.\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = species, y = body_mass_g, color = species)) +\n  geom_violin() +\n  geom_jitter()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-28-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## A categorical and a numerical variable\n\nAnother alternative to displaying the distribution of body weights in the three penguin species is to combine their densities into one plot in the usual way, i.e. with the numerical variable on the `x` axis.\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = body_mass_g, fill = species)) +\n  geom_density()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-29-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## A categorical and a numerical variable\n\nNow, the densities are overlapping. To avoid this, we could of course not map the `fill` aesthetic. A nice alternative is to set the `alpha` aesthetic, which controls **transparency**. 0 is max transparency, 1 is max opaqueness (default).\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = body_mass_g, fill = species)) +\n  geom_density(alpha = 0.5)\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-30-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Two categorical variables\n\nWe can use **grouped or stacked bar plots** to visualize the relationship between two categorical variables. For example, we might want to see how often the different species occur on the different islands.\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_freq <- as.data.frame(table(penguins$species, penguins$island))\nnames(species_freq)[1:2] <- c(\"species\", \"island\")\n\nggplot(species_freq, aes(x = island, y = Freq, fill = species)) +\n  geom_bar(stat = \"identity\")\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-31-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Two categorical variables\n\nWe can create variations of this plot by changing the `position` argument of `geom_bar`. The default is `stack`. Most useful for comparing distributions are relative frequency plots achieved with `position = \"fill\"`:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(species_freq, aes(x = island, y = Freq, fill = species)) +\n  geom_bar(stat = \"identity\", position = \"fill\")\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-32-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Two numerical variables\n\nIn the introductory example, we have already seen **scatter plots** and **smooth curves** as ways to illustrate the relationship between two numerical variables. Scatter plots are an absolute staple in a data scientist's toolbox:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-33-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Three or more variables\n\nThe introductory example displayed three variables: `flipper_length_mm` (`x`), `body_mass_g` (`y`) and `species` (`color` and `shape`). In general, we have the following options to introduce additional variables into a scatter plot:\n\n-   Use additional **aesthetics**:\n    -   Colour $\\to$ `color` (categorical or numerical variables)\n    -   Shape $\\to$ `shape` (categorical)\n    -   Size $\\to$ `size` (categorical or numerical variables)\n    -   Transparency $\\to$ `alpha` (categorical or numerical variables)\n-   Split plot into **facets**, subplots that each display one subset of the data (categorical variables).\n-   Animate the plot (categorical or numerical variables, especially time).\n-   Create a 3D scatter plot (categorical or numerical variables).\n\n\n## Three or more variables\n\n-   When using aesthetics to represent additional variables, we must be aware that different sorts of variables can be represented more or less well by different kinds of visual representations.\n-   While there are no one-size-fits-all recipes, consider the following order as a heuristic when introducing additional variables into a 2D scatter plot:\n    -   For **continuous variables**: size, colour, transparency.\n    -   For **categorical variables**: colour, shape.\n- For example, in our scatter plot of penguin flipper lengths vs. body masses, we might want to introduce categorical information on **species** and **island**. By the heuristic, we use colour for the first and shape for the second.\n\n\n## Three or more variables -- Colour and shape\n\nIn the default setting, the points are quite small, which makes it hard to distinguish the shapes. To mitigate this, we additionally set the `size` aesthetic to something larger, namely 3.\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g,\n                     color = species, shape = island)) +\n  geom_point(size = 3)\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-34-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Three or more variables -- Colour and size\n\nLet's say we wanted a scatter plot of penguin bill length vs. bill depth for different species. Additionally, we want information on body mass included as well. A logical choice to represent the latter would be `size`:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm,\n                     color = species, size = body_mass_g)) +\n  geom_point()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-35-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Three or more variables -- Multiple aesthetics\n\nIf we now really wanted to go mad, we could add the island back in via the `shape` aesthetic and additionally include the flipper length via the `alpha` aesthetic, so that longer flippers are represented by more opaque points:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm,\n                     color = species, size = body_mass_g,\n                     shape = island, alpha = flipper_length_mm)) +\n  geom_point()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-36-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Three or more variables -- Faceting\n\n-   Clearly, there is now **too much information** in this plot.\n-   Adding too many aesthetic mappings to a plot makes it **cluttered** and difficult to make sense of.\n-   Another way to introduce additional categorical variables is to split your plot into several **facets**.\n-   A facet is a **subplot** that displays one subset of the data. For example, there could be one facet for each factor level of a categorical variable.\n-   We can use facets to explore **conditional relationships**, like the relationship between flipper length and body weight on each of the three islands.\n\n\n## Three or more variables -- Faceting\n\nTo facet a plot by a single variable, we use `facet_wrap`. It takes a so-called **formula** as its first argument, which we create with `~` followed by the name of a categorical variable.\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g,\n                     color = species)) +\n  geom_point() +\n  facet_wrap(~island)\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-37-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Three or more variables -- Faceting\n\nTo facet a plot by two variables, we use `facet_grid`. We specify the variable to be faceted in the **rows** before the `~` and the variable to be faceted in the **columns** after it. For example, we could additionally facet `sex` in the rows:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g,\n                     color = species)) +\n  geom_point() +\n  facet_grid(sex~island)\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-38-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Three or more variables -- Labels\n\n-   For some data sets, we can also display an additional variable in a scatter plot by creating informative **labels** for the points.\n-   Our penguin data set is not a good example to illustrate this, so we consider the `elections_historic` data set from the `socviz` package instead:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(socviz)\n    elections_historic <- as.data.frame(elections_historic)\n    head(elections_historic[, c(\"year\", \"winner\", \"win_party\", \"ec_pct\",\n                                \"popular_pct\", \"winner_label\")])\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n      year                 winner win_party ec_pct popular_pct  winner_label\n    1 1824      John Quincy Adams     D.-R. 0.3218      0.3092    Adams 1824\n    2 1828         Andrew Jackson      Dem. 0.6820      0.5593  Jackson 1828\n    3 1832         Andrew Jackson      Dem. 0.7657      0.5474  Jackson 1832\n    4 1836       Martin Van Buren      Dem. 0.5782      0.5079    Buren 1836\n    5 1840 William Henry Harrison      Whig 0.7959      0.5287 Harrison 1840\n    6 1844             James Polk      Dem. 0.6182      0.4954     Polk 1844\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   This data set contains information on US presidential elections from 1824 to 2016. We will have a look at the winner's share of the electoral college vote and the popular vote.\n\n\n## Three or more variables -- Labels\n\nIn a scatter plot, we want to have the popular vote share on the `x` axis and the electoral college vote share on the `y` axis. If we only map these two aesthetics, the plot looks quite uninformative...\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(elections_historic, aes(x = popular_pct, y = ec_pct)) +\n  geom_point()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-40-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Three or more variables -- Labels\n\nWe do not know who any of these points represent. This is a perfect use case for **labeling** the points. For this, we can use the `label` aesthetic together with the `text` **geom** (there is also a `label` geom, which would work as well):\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(elections_historic, aes(x = popular_pct, y = ec_pct, label = winner_label)) +\n  geom_text() +\n  geom_point()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-41-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Three or more variables -- Labels\n\nThat is much better already. However, now, there is a lot of overlap. To remedy this, we need an additional library called `ggrepel`, which provides us with a `text_repel` **geom** to avoid overlapping labels:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggrepel)\nggplot(elections_historic, aes(x = popular_pct, y = ec_pct, label = winner_label)) +\n  geom_text_repel() +\n  geom_point()\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-42-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Customizing our plots\n\n-   So far, we have seen how to create and extend basic plots, like bar plots, density plots, histograms, and scatter plots by tailoring aesthetic mappings and layering on suitable **geoms** according to our needs.\n-   However, the customization usually does not stop there. We might want to ...\n    -   ... add informative titles, subtitles, captions and axis labels to the plot.\n    -   ... use colours and shapes different from the ones `ggplot` uses by default.\n    -   ... adapt the scale of the `x` and / or `y` axis.\n    -   ... change the font type and size for labels and titles.\n    -   ... set the whole plot in a different theme to suit corporate guidelines.\n    -   ... and so much more...\n-   In `ggplot2`, virtually every aspect of a plot is **customizable**. We will only have a look at how to customize some of the most important ones.\n\n\n# Getting the details right -- Scales, guides and themes\n\n## Understanding scales, guides and themes\n\n-   Outside of aesthetic mappings and geoms, there are three types of functions that do most of the heavy lifting when it comes to customizing our plot:\n    -   The family of `scale_` functions\n    -   The `guides` function and\n    -   The `theme` function.\n-   Due to the sheer amount of options for customizability and the partial overlap between some of these functions, things can become confusing very quickly when working through these functions.\n-   Let's start with a basic delineation of scales, guides and themes.\n\n\n## Understanding scales, guides and themes\n\n-   A rough guide on the use of these functions is the following:\n    -   **Scales**: every aesthetic mapping has a scale. If we want to adjust how that scale is marked or graduated, we use a `scale_` function.\n    -   **Guides**: Many scales come with a legend to help us interpret the graph. These are called guides and can be adjusted with the help of the `guides` function.\n    -   **Themes**: graphs have other features not strictly connected to the structure of the data being displayed. These include background colour, font size, legend placement, etc. To adjust these, we use the `theme` function.\n-   We will now dig deeper into each of these three domains of customization and see examples of how the corresponding functions are used to change the appearance of the data displayed.\n\n\n## Understanding scales\n\nLet's come back to an earlier example from the penguin data set:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g,\n                     color = species, shape = island)) +\n  geom_point(size = 3)\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-44-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Understanding scales\n\nThis plot has four aesthetic mappings:\n\n-   The variable `flipper_length_mm` is mapped to `x`.\n-   The variable `body_mass_g` is mapped to `y`.\n-   The variable `species` is mapped to `color`.\n-   The variable `island` is mapped to `shape`.\n\n. . .\n\nAnd each of these mappings has a **scale**:\n\n-   `flipper_length_mm` is a **continuous** variable, so the `x` scale is continuous.\n-   `body_mass_g` is a **continuous** variable, so the `y` scale is continuous.\n-   `species` is an unordered **categorical** variable, so the `color` scale is discrete.\n-   `island` is an unordered **categorical** variable, so the `shape` scale is discrete.\n\n\n## Understanding scales\n\n-   Scales for these mappings may have labels, axis tick marks at particular positions, or specific colours or shapes. If we want to adjust them, we use one of the `scale_` functions.\n-   These functions have the following general structure:\n\n    ![](img/scale_funcs.png){fig-align=\"center\"}\n\n-   So, for example:\n    -   `scale_x_continuous` controls `x` scales for continuous variables\n    -   `scale_y_continuous` controls `y` scales for continuous variables\n    -   `scale_color_discrete` controls `color` scales for discrete variables\n    -   `scale_shape_discrete` controls `shape` scales for discrete variables\n\n\n## Scales in action\n\nLet's see this in action. Say we wanted to override the default for tick marks by having a mark every 5 mm on the `x` axis and every 500 g on the `y` axis. We can use the `breaks` argument to control the position of the tick marks:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g,\n                     color = species, shape = island)) +\n  geom_point(size = 3) +\n  scale_x_continuous(breaks = seq(170, 230, by = 5)) +\n  scale_y_continuous(breaks = seq(3000, 6000, by = 500))\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-45-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Scales in action\n\nNow, let's say we also wanted to change the colours and shapes used to represent species and island, respectively. For **manually** adapting them, we use `scale_color_manual` and `scale_shape_manual`:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g,\n                     color = species, shape = island)) +\n  geom_point(size = 3) +\n  scale_x_continuous(breaks = seq(170, 230, by = 5)) +\n  scale_y_continuous(breaks = seq(3000, 6000, by = 500)) +\n  scale_color_manual(values = c(\"red\", \"blue\", \"green\")) +\n  scale_shape_manual(values = c(17, 18, 8))\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-46-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## A word on shapes\n\n-   The following shapes are most commonly used in R:\n\n    ![](img/points_symbols.png){fig-align=\"center\" width=\"30%\"}\n\n-   You can reference them by using the numbers indicated and passing them to `scale_shape_manual` in the order of the factor levels.\n-   In the example before, we had `Biscoe = 17`, `Dream = 18` and `Torgersen = 8`.\n\n\n## A word on colour\n\n-   Whenever we map `color` or `fill` as an aesthetic, `ggplot2` uses default colour or fill scales that do a fine enough job for exploratory data analysis, but typically have to be tweaked for publication-ready plots.\n-   In the example before, we have **manually** overridden the default using `scale_color_manual` and the names of three colours (red, blue and green).\n-   Choosing the right colour(s) for data visualization is actually a very complex problem that has to consider adequate representation of the underlying data as well as differences in colour perception.\n-   We will only briefly skim the surface of colour choice by looking into some of the excellent options for setting colours that already exist out of the box in `ggplot2`.\n\n\n## A word on colour\n\n-   A collection of colours used for representing data is called a **palette**.\n-   A very popular family of such palettes available in `ggplot2` are the `colorbrewer` palettes. For **discrete** variables, they come in three different types:\n    -   **Qualitative**: best suited to represent unordered categorical data, e.g. penguin species.\n    -   **Sequential**: best suited to represent ordered data that progresses from low to high, e.g. school grades or counts.\n    -   **Diverging**: best suited to represent ordered data with a neutral midpoint and extremes diverging in both directions, e.g. Likert scales.\n-   Depending on the type of data we want represented, we can choose a palette from the corresponding family.\n\n\n## A word on colour -- Qualitative palettes\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-47-1.png){width=1344}\n:::\n:::\n\n\n\n\n## A word on colour -- Sequential palettes\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-48-1.png){width=1344}\n:::\n:::\n\n\n\n\n## A word on colour -- Diverging palettes\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-49-1.png){width=1344}\n:::\n:::\n\n\n\n\n## A word on colour -- How to use colorbrewer\n\n-   We can access all of these palettes in our plots by referencing them using the names given in the functions `scale_color_brewer` and `scale_fill_brewer`, respectively.\n-   In our example, we have the `species` variable mapped to colour, which is an unordered categorical variable. A suitable palette to represent it might therefore be `Dark2`, for example.\n-   To do this, we would run the following code (result on the next slide):\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"6\"}\n    ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g,\n                         color = species, shape = island)) +\n      geom_point(size = 3) +\n      scale_x_continuous(breaks = seq(170, 230, by = 5)) +\n      scale_y_continuous(breaks = seq(3000, 6000, by = 500)) +\n      scale_color_brewer(palette = \"Dark2\")\n    ```\n    :::\n\n\n\n\n## A word on colour -- How to use colorbrewer\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-50-1.png){width=1344}\n:::\n:::\n\n\n\n\n## A word on colour -- How to use colorbrewer\n\n-   With these `colorbrewer` palettes, we can represent data from **discrete** variables, like categorical or count data.\n-   However, what if we want to represent a **continuous** variable using colour, such as penguin bill length?\n-   All **sequential** and **diverging** `colorbrewer` palettes can also be used for continuous scales. Depending on the aesthetic, we only have to pass them into the functions `scale_color_distiller` or `scale_fill_distiller`.\n-   Penguin bill length does not have a neutral midpoint, so we use a sequential palette like `YlOrRd` to represent it (result on the next slide):\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"2,6\"}\n    ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g,\n                         color = bill_length_mm)) +\n      geom_point(size = 3) +\n      scale_x_continuous(breaks = seq(170, 230, by = 5)) +\n      scale_y_continuous(breaks = seq(3000, 6000, by = 500)) +\n      scale_color_distiller(palette = \"YlOrRd\")\n    ```\n    :::\n\n\n\n\n## A word on colour -- How to use colorbrewer\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-51-1.png){width=1344}\n:::\n:::\n\n\n\n\n## A final word on colour\n\n-   The options for colour choice are virtually endless. The goal here was merely to introduce colour scales and how to change them.\n-   If you find yourself unhappy with the colour palettes provided by `colorbrewer`, have a look at the [Palette Finder](https://r-graph-gallery.com/color-palette-finder) in the R Graph Gallery:\n\n    ![](img/palette_finder.png){fig-align=\"center\" width=\"72.5%\"}\n\n\n## Understanding guides\n\nNow let's discuss **guides**. For this, consider again our violin plot from earlier:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-52-1.png){width=1344}\n:::\n:::\n\n\n\nThis plot contains redundant information: the species can be inferred from the axis labels, we do not need the additional legend for `species`.\n\n\n## Understanding guides\n\nTo \"switch off\" the guide for a particular aesthetic, we can simply call the `guides` function with the name of the aesthetic as a named argument set to `\"none\"`:\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) +\n  geom_violin() +\n  guides(fill = \"none\")\n```\n:::\n\n\n\n### Plot\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-53-1.png){width=1344}\n:::\n:::\n\n\n:::\n\n\n## Understanding guides\n\n-   Of course, the `guides` function can do much more than simply to \"switch off\" legends for individual scales.\n-   In fact, it can be used to customize virtually every aspect of a legend such as:\n    -   where the title of the legend should go\n    -   where the labels should be placed\n    -   in which orders the labels should be displayed\n    -   and much more...\n-   As with many aspects of `ggplot2`, this bridge is best crossed, when you first come to it...\n\n\n\n## Understanding themes\n\n-   Finally, a very important domain of plot customization is opened up by the `theme` function. It allows us to customize all aspects that are not directly related to the data being displayed.\n-   A very common basic use of the `theme` function is to place the legend at a different location in the plot and to change font sizes of different labels (result on the next slide):\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g,\n                         color = species, shape = island)) +\n      geom_point(size = 3) +\n      labs(title = \"Body mass and flipper length\",\n           subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n           caption = \"Source: palmerpenguins package\",\n           color = \"Species\",\n           shape = \"Island\") +\n      theme(legend.position = \"bottom\",\n            plot.title = element_text(size = rel(1.75)),\n            plot.subtitle = element_text(size = rel(1.5)),\n            plot.caption = element_text(size = rel(0.75)))\n    ```\n    :::\n\n\n\n\n## Understanding themes\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-54-1.png){width=1344}\n:::\n:::\n\n\n\n\n## Using pre-built themes\n\n-   While customizing every single aspect of a plot is definitely possible in `ggplot2`, it is also incredibly cumbersome and usually not necessary.\n-   Instead, we can simply layer on a pre-built **theme** that changes the overall look of a plot all at once.\n-   **Themes** that come shipped with `ggplot2` are: `bw`, `classic`, `dark`, `gray` (default), `light`, `linedraw`, `minimal`, `test` and `void`.\n-   The following slide gives an overview of our plot would look like in each of these themes. If none of those suit your needs, you can have a look at the `ggthemes` package that has plenty more to [offer](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/).\n\n\n## Using pre-built themes\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04_The_Data_Science_Workflow_II_files/figure-revealjs/unnamed-chunk-55-1.png){width=1344}\n:::\n:::\n\n\n\n\n## Saving your work\n\n-   Now that we know how to create and customize our own plots, we might want to **save** them to include them in a presentation or send them to a colleague.\n-   The easiest way to do this is to use the function `ggsave`. By default, it will save the most recently created plot into the file name you provide:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ggsave(filename = \"my_figure.png\")\n    ```\n    :::\n\n\n\n-   You can save the plot as PDF, JPG, PNG (or several other formats) by changing the **file ending** accordingly.\n-   You can also change the dimensions and the resolution of the plot by changing arguments `width`, `height` and `dpi`, respectively.\n-   As always, for more details, refer to the documentation via `?ggsave`.\n\n\n# A sneak peek into what is possible\n\n## A sneak peek into what is possible\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n![](gifs/gapminder.gif)\n\n",
    "supporting": [
      "04_The_Data_Science_Workflow_II_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}