{
  "hash": "086ba5857d195bc83ff1bb08d6300785",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Science and Data Analytics\"\nsubtitle: \"The Essentials of R Programming\"\nauthor: \"Julian Amon, PhD\"\ndate: \"March 21, 2025\"\ndate-format: long\ninstitute: Charlotte Fresenius Privatuniversität\nfooter: \"Data Science and Data Analytics -- R essentials\"\nformat:\n  revealjs:\n    theme:\n      - default\n      - slides.scss\n    width: 1350\n    height: 900\n    slide-number: true\n    logo: img/UOS_Logo.jpg\n    fig-width: 14\n    controls: true\n    embed-resources: true\nhighlight-style: arrow\nexecute: \n  warning: true\n  echo: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n# R and RStudio\n\n\n\n\n\n\n\n## Programming languages for Data Science\n\n![](img/rvspython1.jpg){fig-align=\"center\"}\n\n. . .\n\n![](img/rvspython2.jpg){fig-align=\"center\"}\n\n## What is R?\n\n![](img/r_logo.png){.absolute top=\"0\" left=\"1150\" width=\"8%\"}\n\n-   **R** is an open-source statistical **programming language**.\n-   R is *not* a programming language like C or Java. It was not created by software engineers for software development. Instead, it was developed by statisticians as an environment for statistical computing and graphics.\n-   Some of its attractive features are:\n    -   R is free and [open source](https://opensource.org/history).\n    -   R runs on all major platforms: Windows, macOS, UNIX/Linux.\n    -   There is a large, growing, and active community of R users and, as a result, there are numerous resources for learning and asking questions.\n    -   It is easily extensible through **packages**. In this way, it is easy to share software implementations of new data science methodologies.\n\n## A (very) brief history of R\n\n![](img/r_logo.png){.absolute top=\"0\" left=\"1150\" width=\"8%\"}\n\n-   R was first developed by Robert Gentleman and Ross Ihaka (University of Auckland, New Zealand) in the 1990s.\n-   Very early in the development of R, two statisticians at **TU Vienna** (Kurt Hornik and Fritz Leisch) got word about the initiative in New Zealand and started contributing to R.\n-   Soon, the growing interest in this project from researchers all over the world led to the establishment of the [**R Core team**](https://www.r-project.org/contributors.html), which maintains R to this day.\n-   The strong involvement of the two Viennese researchers also led to the establishment of the [**R Foundation for Statistical Computing**](https://www.r-project.org/foundation/) in Vienna (now at WU). Its main mission is the support of the continued development of R.\n-   Today, R is the lingua franca of statistics and an essential tool for data science.\n\n## Importance of R in Data Science\n\n![](img/ds_proglangs.jpg){fig-align=\"center\"}\n\n## What is RStudio?\n\n![](img/rstudio_logo.png){.absolute top=\"0\" left=\"1150\" width=\"7.5%\"}\n\n-   **RStudio** is a convenient interface for R called an integrated development environment (IDE). An IDE is the program on a computer that a developer uses to write code.\n-   RStudio is an open-source IDE by [Posit](https://posit.co/) specifically designed to support developers in writing **R code**. It is not a requirement for programming with R, but it is very commonly used by R programmers and data scientists.\n\n![](img/r_vs_rstudio.png){fig-align=\"center\" width=\"75%\"}\n\n## What is RStudio?\n\n![](img/rstudio_meme.jpg){fig-align=\"center\"}\n\n## A Tour of RStudio\n\n![](img/rstudio_tour.png){fig-align=\"center\"}\n\n## A Tour of RStudio\n\n-   While we can write and execute code directly in the **R console** in the bottom left pane in RStudio, it is better to write all code in an **R script**.\n-   An R script is simply a text file that contains R code.\n-   In RStudio, R scripts can be opened, viewed and edited in the top left pane. To open a new R script, go to `File > New File > R script`.\n-   A single line of code in an R script can be sent to the console for execution via `Ctrl + Enter` (or `Cmd + Enter` on Mac).\n-   To write a comment in an R script, simply put a hashtag (#) in front of the comment:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This is our first R script\n2 + 2 # We calculate 2 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n# First steps\n\n## First steps in R -- Mathematical operators\n\nFirst, let's use R as a **calculator**. We can write a calculation into our R script and R will give us the result, when the code is executed:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 3 # Addition\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\n2 - 4 # Subtraction\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -2\n```\n\n\n:::\n\n```{.r .cell-code}\n3 * 4 # Multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n\n```{.r .cell-code}\n4 / 2 # Division\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n3^3 # Exponentiation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 27\n```\n\n\n:::\n\n```{.r .cell-code}\n(2 + 3)*(3 + 4) # Bracketing\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35\n```\n\n\n:::\n\n```{.r .cell-code}\n2^(3 + 4/2)*4 # All together\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 128\n```\n\n\n:::\n:::\n\n\n\n## First steps in R -- Relational and logical operators\n\nWe can also perform comparisons using R:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3 < 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n3 > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n3 <= 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n3 >= 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n3 == 5 # Attention for the double equal sign!\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n3 != 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nWith the help of `&` and `|`, we can also carry out `AND` and `OR` operations:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(3 == 5) | (5 == 5) # OR\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n(3 == 5) & (5 == 5) # AND\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n## First steps in R -- Functions\n\nR comes with many functions that you can use to perform tasks from simple to sophisticated. Functions have **inputs** (aka **arguments**) that you pass into them and **outputs** (aka **return values**) that they give back. Functions are fundamental to how R works.\n\n. . .\n\nLet's see an example. Say, we want to round the number 5.293586 to two decimal digits. Fortunately, there is a function in R called `round`. But how do we use it?\n\nTo find out, we can bring up the R help, which provides documentation for every function in R, by typing `?` and the name of the function into the console:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?round\n```\n:::\n\n\n\n## First steps in R -- Functions\n\n![](img/r_help_round.png){fig-align=\"center\"}\n\n## First steps in R -- Functions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(5.293586, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.29\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nGenerally, we can use the `args` function to see the arguments that a function takes. For example, let's say, we wanted to simulate someone throwing a regular die, i.e. randomly **sample** numbers from 1 to 6. Luckily, there is an R function called `sample`. Let's inspect it.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(sample)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, size, replace = FALSE, prob = NULL) \nNULL\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nTo find out more information on what these arguments actually mean, let's consult the documentation again:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?sample\n```\n:::\n\n\n\n## First steps in R -- Functions\n\n![](img/r_help_sample.png){fig-align=\"center\"}\n\n## First steps in R -- Functions\n\nSo, to simulate 20 throws of a regular die, we have to use the function like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(6, 20, replace = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 5 1 1 2 4 2 2 1 4 1 5 6 4 2 2 3 1 1 3\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nNote that we can give the arguments to the function\n\n::: incremental\n-   in the order that they are given in the documentation (then they do not need to be named).\n-   by explicitly naming them when calling the function (then the order does not matter).\n-   by mixing unnamed and named arguments (like we have done here). \n:::\n\n. . .\n\nLet's see another example of this.\n\n## First steps in R -- Functions\n\nLet's say, we wanted to compute the base 2 logarithm of 10. For this, we need the `log` function in R:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(log)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, base = exp(1)) \nNULL\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nSo, based on the three options given on the previous slide, all of the following three ways of calling `log` lead to the correct result:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(10, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(base = 2, x = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(10, base = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n:::\n\n\n\nHowever, options 1 and 3 are preferable, as switching the order of arguments tends to make code less easily readable for others (which could be yourself in the future...)\n\n## First steps in R -- Variables and assignment\n\nLet's say, you were given the task to solve the quadratic equation\n\n$$3x^2 - 5x - 1 = 0$$\n\nYou will remember from back in your high school days that we can use the \"midnight formula\" for this:\n\n$$x_{1/2} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$\n\nWith R, we can easily compute this of course:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(-(-5) + sqrt((-5)^2 - 4*3*(-1)))/(2*3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.847127\n```\n\n\n:::\n\n```{.r .cell-code}\n(-(-5) - sqrt((-5)^2 - 4*3*(-1)))/(2*3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.1804604\n```\n\n\n:::\n:::\n\n\n\n## First steps in R -- Variables and assignment\n\nNext, we are given another quadratic equation\n\n$$4x^2 - 8x + 2 = 0$$\n\nTo compute the solution with R, we would have to replace every occurrence of $a$, $b$ and $c$, so in total, we would have to make 10 replacements to get both solutions. That's too cumbersome and error-prone...\n\n. . .\n\nInstead, we can define **variables** $a$, $b$ and $c$ and simply **assign** different values to them every time we have to solve a quadratic equation. Such assignments happen in R with the help of the assignment operator `<-` (read it as \"gets\"):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 3\nb <- -5\nc <- -1\n# Note that nothing is printed to the console when assigning variables.\n```\n:::\n\n\n\nNow, we can write expressions using these variables like we would in maths.\n\n## First steps in R -- Variables and assignment\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(-b + sqrt(b^2 - 4*a*c))/(2*a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.847127\n```\n\n\n:::\n\n```{.r .cell-code}\n(-b - sqrt(b^2 - 4*a*c))/(2*a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.1804604\n```\n\n\n:::\n:::\n\n\n\nNow, to compute the solution to the second quadratic equation, we simply re-define the variables `a`, `b` and `c` and then evaluate the same expression again:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 4\nb <- -8\nc <- 2\n\n(-b + sqrt(b^2 - 4*a*c))/(2*a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.707107\n```\n\n\n:::\n\n```{.r .cell-code}\n(-b - sqrt(b^2 - 4*a*c))/(2*a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2928932\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nNote that R is **case-sensitive**, so it now knows variables with names `a`, `b` and `c`, but it does not know `A`, `B` or `C`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: Objekt 'A' nicht gefunden\n```\n\n\n:::\n:::\n\n\n\n\n## First steps in R -- Variables and assignment\n\nWith assignments, we are creating **objects** in R that are saved and can be referenced by the names that we give them (e.g. `a`, `b` and `c`). Creating **objects** like this will make them appear in the work space in pane 4 of the RStudio window:\n\n![](img/workspace.png){.nostretch fig-align=\"center\" width=\"75%\"}\n\nWe can also see all variables currently defined in the work space by typing `ls()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\n\n## First steps in R -- User-defined functions\n\nWith the assignment operator, we can also define our own functions of course! To define a function, we need a **function name**, **arguments**, a **function body** and a **return value**:\n\n![](img/r_function_syntax.png){.nostretch fig-align=\"center\" width=\"75%\"}\n\n\n## First steps in R -- User-defined functions\n\nConsider the following example: say we want to write a function called `quadratic_solver` (function **name**) that gives us the solution to any quadratic equation. It needs input **arguments** `a`, `b` and `c` and should **return** the two solutions. In the function **body**, the two solutions should be computed for the three inputs. So, we could create the function as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadratic_solver <- function(a, b, c){\n  sol_1 <- (-b + sqrt(b^2 - 4*a*c))/(2*a)\n  sol_2 <- (-b - sqrt(b^2 - 4*a*c))/(2*a)\n  return(c(sol_1, sol_2))\n}\n```\n:::\n\n\n\n. . .\n\nNow, we can use this function like any other:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadratic_solver(3, -5, -1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.8471271 -0.1804604\n```\n\n\n:::\n\n```{.r .cell-code}\nquadratic_solver(4, -8, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.7071068 0.2928932\n```\n\n\n:::\n:::\n\n\n\n\n# Data types and Data structures\n\n## Data types in R\n\nIn R, the following six **data types** are available:\n\n-   double (i.e., double precision floating-point number -- R lingo for real number),\n-   integer,\n-   character (sometimes referred to as string),\n-   logical/boolean (can only take values `TRUE` or `FALSE`),\n-   complex (as in complex numbers, not relevant for us),\n-   raw (not relevant for us),\n\nWe can find the type of an object using the function `typeof`. We can verify, whether an object is of a certain `<type>` by using the function `is.<type>`. Let's see some examples.\n\n## Double\n\nBy default, R will save any number that you type in as a `double`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 2\nb <- 3.141593\n\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.double(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.double(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\nTogether with `integer`, the data type `double` is one of the two `numeric` types, i.e. representing numbers:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.numeric(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n## Integer\n\n**Integers** (whole numbers) are (positive or negative) numbers that can be written without a decimal component. This data type is more important for developers as it saves memory (compared to doubles). To specify an integer over a double, the number has to be followed by an uppercase `L`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 10L\n\ntypeof(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.integer(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.double(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n(Pure) integers are also `numeric` of course:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n## Character\n\nText data is represented in R with the help of the `character` data type. To demarcate a string of characters, you can use double or single quotes (`\"\"` or `''`).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletter <- \"a\"\nw <- 'Hello, world.'\n\ntypeof(letter)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(letter)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\nOf course, `character` objects are *not* numeric.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(letter)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.numeric(w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n## Logical\n\nWhen working with relational operators, we already saw a couple of instances of the `logical` data type. It can only take the values TRUE and FALSE. Negation of a `logical` object (i.e. saying **NOT**) can be achieved with the help of the `!` operator:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbigger <- 5 > 3\n\ntypeof(bigger)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.logical(bigger)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n!bigger\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n`Logical` objects are also *not* numeric.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(bigger)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.numeric(!bigger)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n## Type coercion\n\nWe can **coerce** an object to be of a certain `<type>` by using the function `as.<type>`. This process is called **type coercion**.\n\nIn some cases, this is very intuitive...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.double(\"2.71828\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.71828\n```\n\n\n:::\n\n```{.r .cell-code}\nas.integer(\"10\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(\"10\") # creates a double\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nas.character(42)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"42\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n... in others, maybe not so much...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(2.9) # returns the closest smaller integer\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(2.9) # returns TRUE for any number other than 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n## Special values\n\nNon-sensical attempts at coercion are translated as `NA` (not available).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(\"Hello, world.\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: NAs durch Umwandlung erzeugt\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(\"5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n`NA` is one of four **special values**. While `NA` can occur for any data type, the other three can only occur for `numeric` data types. These are:\n\n-   `Inf`: positive infinity\n-   `-Inf`: negative infinity\n-   `NaN`: not a number\n\nWhile they are not technically numbers, these special values still follow logical rules when applying mathematical operations on them.\n\n## Special values\n\n::::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n\n```{.r .cell-code}\n2 / 0 + 2 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n\n```{.r .cell-code}\n-2 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -Inf\n```\n\n\n:::\n\n```{.r .cell-code}\n-2 / 0 - 2 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -Inf\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n\n```{.r .cell-code}\n2 / 0 - 2 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n\n```{.r .cell-code}\n- 1 / 0 + 2 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n:::\n\n\n:::\n:::::\n\n. . .\n\nUnlike `NaN`, `NA`s are genuinely **unknown** values. Nevertheless, they also have their logical rules. Consider the following example. Let's think about why each of the following four results makes sense:\n\n::::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE | NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE & NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFALSE | NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE & NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n:::\n:::::\n\n. . .\n\nNote: all special values have their own `is.<special>` function to check for them, i.e. `is.na`, `is.nan` and `is.infinite`.\n\n\n## Data structures\n\n-   On top of these six basic **data types**, R builds several kinds of more complex **data structures** in different ways to suit different applications that are regularly encountered in the statistics / data science context.\n-   We will use the following regularly and hence discuss them in more detail:\n    -   (Atomic) `vector`\n    -   `list`\n    -   `matrix`\n    -   `data.frame`\n    -   `factor`\n    -   `Date`\n\n## Atomic vector\n\nAn **atomic vector** is a simple vector of values of **one data type**. Values can be **concatenated** together into a vector using the `c` function. For example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3, 4, 5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nSince we have filled the vector `x` with values of type `double`, it will itself also be of type `double`. It has several attributes / characteristics such as `length`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.double(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nWe can also assign names to the vector elements:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(x) <- c(\"a\", \"b\", \"c\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c \n3 4 5 \n```\n\n\n:::\n:::\n\n\n\n\n## Atomic vector\n\nWhat happens if we try to create a vector with data of different types?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(1, \"a\", TRUE)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"    \"a\"    \"TRUE\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nWhen we attempt to combine different types, R will **coerce** the data in a fixed order, namely `character` $\\to$ `double` $\\to$ `integer` $\\to$ `logical`, i.e. if any data of a higher-order type appears in the vector creation, the vector will be of that type:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n. . . \n\nSo, what will be the type of the following vector?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- c(0L, 1L, 2, TRUE)\n```\n:::\n\n\n\n. . .\n\nAs the `2` is of type `double`, this is the highest-order type in the vector, so:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n## Working with vectors -- Vectorization\n\nMost operations in R are **vectorized**, which means they are (automatically) performed element by element:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c \n3 4 5 \n```\n\n\n:::\n\n```{.r .cell-code}\nx^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c \n 9 16 25 \n```\n\n\n:::\n\n```{.r .cell-code}\nlog(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       a        b        c \n1.098612 1.386294 1.609438 \n```\n\n\n:::\n:::\n\n\n\nThis also applies when we want to add / subtract / multiply / divide two vectors **element-wise**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(5, 12, 13)\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c \n 8 16 18 \n```\n\n\n:::\n\n```{.r .cell-code}\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c \n15 48 65 \n```\n\n\n:::\n:::\n\n\n\n\n## Working with vectors -- Vectorization\n\nIf two vectors are of different lengths, then R recycles the smaller one to allow operations like the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- c(10, 20, 30, 40, 50, 60)\nx + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 22 33 41 52 63\n```\n\n\n:::\n:::\n\n\n\nHowever, **beware of recycling**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- c(10, 20, 30, 40, 50, 60, 70)\nx + y\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in x + y: Länge des längeren Objektes\n \t ist kein Vielfaches der Länge des kürzeren Objektes\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 22 33 41 52 63 71\n```\n\n\n:::\n:::\n\n\n\n\n## Working with vectors -- Sequences\n\nTo create vectors that are **sequences**, there is a very useful R function called `seq`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(2, 20, by = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  8 10 12 14 16 18 20\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(1.2, 0.2, by = -0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1.2 1.1 1.0 0.9 0.8 0.7 0.6 0.5 0.4 0.3 0.2\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nSequences of **consecutive integers** -- like the first one we saw -- are particularly frequently needed in (R) programming. For this reason, there is a short-hand notation (\"syntactic sugar\") to create sequences of that kind, which is `start_value:end_value`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns <- 1:10\ntypeof(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n\n\n## Working with vectors -- Subsetting\n\nIf we want to extract or replace elements of a vector, you can use **square brackets** `[]` with logical or numeric input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalphabet <- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\",\n              \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n# Numeric subsetting\nalphabet[1:3] # first three\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\nalphabet[3:1] # first three in descending order\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"c\" \"b\" \"a\"\n```\n\n\n:::\n\n```{.r .cell-code}\nalphabet[c(2, 4)] # second and fourth\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"b\" \"d\"\n```\n\n\n:::\n\n```{.r .cell-code}\nalphabet[-(1:10)] # all except the first 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n```\n\n\n:::\n\n```{.r .cell-code}\nalphabet[5] <- \"E\" # replace the fifth element by a capital E\n\n# Logical subsetting\nalphabet == \"E\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nalphabet[alphabet == \"E\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"E\"\n```\n\n\n:::\n:::\n\n\n\n\n## Working with vectors -- Subsetting\n\nWe can also use the `which` function to turn a logical vector into an integer vector that gives the indices of all elements in the vector that are `TRUE`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(alphabet == \"E\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nalphabet[which(alphabet == \"E\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"E\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nWith the `%in%` operator, we can check whether elements of the vector are contained **in** another vector:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalphabet %in% c(\"x\", \"y\", \"z\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[25]  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nwhich(alphabet %in% c(\"x\", \"y\", \"z\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24 25 26\n```\n\n\n:::\n\n```{.r .cell-code}\nalphabet[alphabet %in% c(\"x\", \"y\", \"z\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x\" \"y\" \"z\"\n```\n\n\n:::\n:::\n\n\n\n## Working with vectors -- Sorting\n\nFor sorting vectors, we can use the `sort` function. This works with `character` vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sorting a character vector\nunsorted_letters <- sample(alphabet)\nunsorted_letters\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"d\" \"E\" \"m\" \"y\" \"t\" \"b\" \"h\" \"c\" \"a\" \"j\" \"v\" \"n\" \"k\" \"f\" \"q\" \"p\" \"z\" \"l\" \"x\"\n[20] \"u\" \"w\" \"i\" \"r\" \"g\" \"s\" \"o\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsorted_letters <- sort(unsorted_letters)\nsorted_letters\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a\" \"b\" \"c\" \"d\" \"E\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n... as well as with numeric vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sorting a numeric vector in decreasing order:\nunsorted_numbers <- sample(1:20)\nunsorted_numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  3 17 18  6 19  2  4 20 16  5 15  7 12 10  9 11  1 14 13  8\n```\n\n\n:::\n\n```{.r .cell-code}\nsorted_numbers <- sort(unsorted_numbers, decreasing = TRUE)\nsorted_numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1\n```\n\n\n:::\n:::\n\n\n\n\n## List\n\nLists are a step up in complexity from atomic vectors: each element can be any type, not just vectors. We construct lists with the function `list`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- list(1:3, \"R\", c(TRUE, FALSE, TRUE), c(2.3, 5.9))\n\nl1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"R\"\n\n[[3]]\n[1]  TRUE FALSE  TRUE\n\n[[4]]\n[1] 2.3 5.9\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n\nLists are sometimes called **recursive** vectors because a list can contain other lists. This makes them fundamentally different from atomic vectors.\n\n\n## List\n\nThe elements of a list can also have names. These can be accessed with the help of the `$` operator. Alternatively, to access **a single** element of a list, we can also use **double square brackets** `[[]]`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(l1) <- c(\"A\", \"B\", \"C\", \"D\")\nl1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$A\n[1] 1 2 3\n\n$B\n[1] \"R\"\n\n$C\n[1]  TRUE FALSE  TRUE\n\n$D\n[1] 2.3 5.9\n```\n\n\n:::\n\n```{.r .cell-code}\nl1$A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nl1[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nl1[[\"D\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.3 5.9\n```\n\n\n:::\n:::\n\n\n\n\n## Working with lists -- Subsetting\n\nFor subsetting lists, essentially the same rules apply as for atomic vectors, i.e. we can subset using numeric or logical arguments and single square brackets `[]`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Numeric subsetting\nl1[1:2] # First two elements\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$A\n[1] 1 2 3\n\n$B\n[1] \"R\"\n```\n\n\n:::\n\n```{.r .cell-code}\nl1[-(1:2)] # All elements except the first\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$C\n[1]  TRUE FALSE  TRUE\n\n$D\n[1] 2.3 5.9\n```\n\n\n:::\n\n```{.r .cell-code}\n# Logical subsetting\nl1[c(FALSE, FALSE, FALSE, TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$D\n[1] 2.3 5.9\n```\n\n\n:::\n:::\n\n\n\n\n## Matrix\n\nOne way to construct more complex data structures on top of elementary building blocks like vectors or lists is to assign a `class` to them. A **class** is metadata about the object that can determine how common functions operate on that object.\n\n. . .\n\nProbably the easiest example of this is a `matrix`. A matrix is just a two-dimensional array of numbers:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:12, nrow = 3, ncol = 4)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n\n\n:::\n:::\n\n\n\nThe function `matrix` will fill up the matrix column by column by default. There is an option to fill them by row instead, see `?matrix`.\n\n## Matrix\n\nTechnically speaking, in R, a matrix is actually just a vector with an **attribute** that specifies the **dimensions** (i.e. number of rows and columns) of the matrix. We can access the dimensions of a matrix with the help of the functions `dim`, `nrow` and `ncol`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(m) # just an integer vector behind the scenes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(m) # but dimensions are 3 x 4 (3 rows, 4 columns)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(m) # number of rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(m) # number of columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(m) # It is of class matrix and array\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n\n\n\n## Matrix\n\nWe can add additional rows or columns with the help of `rbind` or `cbind`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- cbind(m, c(13, 14, 15))\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n```\n\n\n:::\n\n```{.r .cell-code}\nm <- rbind(rep(1, 5), m)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    1    1    1    1\n[2,]    1    4    7   10   13\n[3,]    2    5    8   11   14\n[4,]    3    6    9   12   15\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nFor a matrix, we can set both **row names** and **column names**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(m) <- c(\"row_1\", \"row_2\", \"row_3\", \"row_4\")\ncolnames(m) <- c(\"A\", \"B\", \"C\", \"D\", \"E\")\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      A B C  D  E\nrow_1 1 1 1  1  1\nrow_2 1 4 7 10 13\nrow_3 2 5 8 11 14\nrow_4 3 6 9 12 15\n```\n\n\n:::\n:::\n\n\n\n\n## Working with matrices -- Subsetting\n\nAs a matrix is a two-dimensional object, we need **two indices** separated by a comma for subsetting. If we do not specify one dimension, all elements across that dimension are selected:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[2, ] # 2nd row\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n A  B  C  D  E \n 1  4  7 10 13 \n```\n\n\n:::\n\n```{.r .cell-code}\nm[, 3] # 3rd column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nrow_1 row_2 row_3 row_4 \n    1     7     8     9 \n```\n\n\n:::\n\n```{.r .cell-code}\nm[3, 4] # 3rd element of the 4th column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nm[c(FALSE, FALSE, FALSE, TRUE), ] # 4th row\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n A  B  C  D  E \n 3  6  9 12 15 \n```\n\n\n:::\n:::\n\n\n\n. . .\n\nWe can also subset by name if column and / or row names are provided:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[\"row_4\", \"E\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n:::\n\n\n\n\n## Data Frame\n\nAs a matrix is basically just a vector underneath, all values still need to be of the same data type. However, real tabular data often includes **data of different types** (e.g. name, height, education). To represent this, we need a data structure where the columns can be of different types.\n\n. . . \n\nIn R, such a data structure is provided by the `data.frame`. Underlying it is a named list, whose elements represent columns. Therefore, all elements need to have **the same length**. Consider the following example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheights <- c(176, 178, 156)\nnames <- c(\"Anna\", \"Jakob\", \"Lisa\")\neduc <- c(\"BSc\", \"MA\", \"PhD\")\ndf <- data.frame(heights = heights, names = names, educ = educ)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  heights names educ\n1     176  Anna  BSc\n2     178 Jakob   MA\n3     156  Lisa  PhD\n```\n\n\n:::\n:::\n\n\n\n## Data Frame\n\n::: slightlysmall\nLet's inspect the \"list nature\" of the `data.frame` object `df` we just created:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n:::\n\n. . .\n\n::: slightlysmall\nEven though `df` is fundamentally a `list`, it behaves differently than a standard list:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  heights names educ\n1     176  Anna  BSc\n2     178 Jakob   MA\n3     156  Lisa  PhD\n```\n\n\n:::\n\n```{.r .cell-code}\nas.list(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$heights\n[1] 176 178 156\n\n$names\n[1] \"Anna\"  \"Jakob\" \"Lisa\" \n\n$educ\n[1] \"BSc\" \"MA\"  \"PhD\"\n```\n\n\n:::\n:::\n\n\n\nThis is because, on top of being a list, the object `df` is of class `data.frame`, which changes how common functions operate on it.\n:::\n\n\n## Working with Data Frames\n\nSince a `data.frame` also represents two-dimensional data, many of the functions we used for matrices work on it as well:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 3\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"heights\" \"names\"   \"educ\"   \n```\n\n\n:::\n:::\n\n\n\n. . . \n\nIn particular, all the subsetting methods we showed are also applicable:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  heights names educ\n1     176  Anna  BSc\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Anna\"  \"Jakob\" \"Lisa\" \n```\n\n\n:::\n\n```{.r .cell-code}\ndf[c(TRUE, TRUE, FALSE), 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"BSc\" \"MA\" \n```\n\n\n:::\n:::\n\n\n\n\n## Working with Data Frames\n\nHowever, as `data.frame`s are lists underneath, we can also use the `$` operator to access the elements of the list as before. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$heights\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 176 178 156\n```\n\n\n:::\n\n```{.r .cell-code}\ndf$names\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Anna\"  \"Jakob\" \"Lisa\" \n```\n\n\n:::\n\n```{.r .cell-code}\ndf$educ\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"BSc\" \"MA\"  \"PhD\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nThis is a particularly common action when working with real data, as it allows us to access the variables in the columns of the `data.frame`. For example, let's say we made a mistake and found out that Jakob was really 187 cm tall. We could change the corresponding data point as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$heights[2] <- 187\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  heights names educ\n1     176  Anna  BSc\n2     187 Jakob   MA\n3     156  Lisa  PhD\n```\n\n\n:::\n:::\n\n\n\n\n## Factor\n\nA `factor` is R's way to represent **categorical data**. Say, for example, we want to add the sex of the three people in our data set to the `data.frame`. For this, we create a factor and add it as an additional column to `df`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsex <- factor(c(\"f\", \"m\", \"f\"))\ndf$sex <- sex\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  heights names educ sex\n1     176  Anna  BSc   f\n2     187 Jakob   MA   m\n3     156  Lisa  PhD   f\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nA `factor` has **levels** that represent the categories that this variable can take (here: \"m\" for male and \"f\" for female). In the background, R stores these levels as integers and keeps a map to keep track of the labels. This is more memory efficient than storing all the characters.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$sex\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] f m f\nLevels: f m\n```\n\n\n:::\n:::\n\n\n\n## Factor\n\nA `factor` is another example of a data structure that is built on top of an atomic vector using a `class` attribute. The data is stored as an integer vector (**data type**), but because the object is of class `factor`, R uses different **methods** to act on the object (compared to a standard integer vector). This type of behaviour is one of the things that makes R very powerful for data science.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(df$sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.integer(df$sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 1\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(df$sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndf$sex\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] f m f\nLevels: f m\n```\n\n\n:::\n:::\n\n\n\nAs we will see, properly encoding categorical data as factors is an essential step in data preparation.\n\n\n## Date\n\nFinally, a common type of data that needs to be represented in R are **dates**. Dates are typically represented in some sort of format like \"DD-MM-YYYY\" in the European context, for instance. Let's say, we are given Anna's, Jakob's and Lisa's birthday in different formats:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbday_anna <- \"1999-12-01\" # YYYY-MM-DD\nbday_jakob <- \"16.4.98\" # MM.DD.YYYY\nbday_lisa <- \"7/June/1995\" # DD/MM/YYYY\n```\n:::\n\n\n\n. . .\n\nR has a specific way of recognizing such date formats using so called **format strings**. For each way of representing date information, there is a corresponding format string. Some important ones are:\n\n::: small\n\n| Format string | Description            | Format string | Description                  |\n|---------------|------------------------|---------------|------------------------------|\n| %Y            | Year with century      | %y            | Year without century         |\n| %m            | Month of year (01-12)  | %j            | Day of the year (0-366)      |\n| %d            | Day of month (01-31)   | %W            | Calendar week (0-53)         |\n| %B            | Full month (e.g. June) | %b            | Abbreviated month (e.g. Jun) |\n\n:::\n\n## Working with dates\n\nSo let's try to use this to convert our dates (which are now just `character` objects) to actual dates that R understands using `as.Date`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbday_anna <- as.Date(\"1999-12-01\", \"%Y-%m-%d\")\nbday_jakob <- as.Date(\"16.4.98\", \"%d.%m.%y\")\nbday_lisa <- as.Date(\"7/June/1995\", \"%d/%B/%Y\")\nbday_anna\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1999-12-01\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbday_jakob\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1998-04-16\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbday_lisa\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1995-06-07\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nNow, we can add these dates as a column to our `data.frame`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$bday <- c(bday_anna, bday_jakob, bday_lisa)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  heights names educ sex       bday\n1     176  Anna  BSc   f 1999-12-01\n2     187 Jakob   MA   m 1998-04-16\n3     156  Lisa  PhD   f 1995-06-07\n```\n\n\n:::\n:::\n\n\n\n\n## Working with dates\n\nDates are stored in R as the number of days since [Unix time](https://en.wikipedia.org/wiki/Unix_time), which is the 1st January, 1970. Hence, date vectors are simply `double` vectors of class `Date`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(df$bday)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.double(df$bday)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10926 10332  9288\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(df$bday)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nWith this underlying representation, we can do maths on dates:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$bday\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1999-12-01\" \"1998-04-16\" \"1995-06-07\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndf$bday + 30\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1999-12-31\" \"1998-05-16\" \"1995-07-07\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndf$bday[2] - df$bday[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of -594 days\n```\n\n\n:::\n:::\n\n\n\n## Working with dates\n\nNote that these operations cannot be performed on the original character strings representing the birthdays:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"1999-12-01\" + 10\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in \"1999-12-01\" + 10: nicht-numerisches Argument für binären Operator\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nTo extract individual parts of a date (like year, month, day, weekday, etc.), we can use the `format` function in conjunction with the format strings we saw before for date creation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformat(df$bday, \"%Y\") # extract birth year\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1999\" \"1998\" \"1995\"\n```\n\n\n:::\n\n```{.r .cell-code}\nformat(df$bday, \"%B\") # extract birth month\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"December\" \"April\"    \"June\"    \n```\n\n\n:::\n\n```{.r .cell-code}\nformat(df$bday, \"%A\") # extract week day of birth date\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Wednesday\" \"Thursday\"  \"Wednesday\"\n```\n\n\n:::\n:::\n\n\n\n\n## Working with dates\n\n![](img/date_format_meme.jpg){fig-align=\"center\"}\n\n\n# Programming basics\n\n## R programming for Data Science\n\n-   By coding in R, we can efficiently perform exploratory data analysis, build machine learning pipelines, and prepare beautiful plots to communicate results effectively using data visualization tools.\n-   However, R is not just a data analysis environment but a **programming language**.\n-   The goal of this is course is not to teach advanced R programming, but in order to facilitate our lives as data scientists, we do need access to certain core programming principles like **conditionals**, **loops** and **functionals**.\n-   So let's dive right in!\n\n\n## Conditionals\n\n**Conditionals** are one of the basic features of programming. They are used for what is called **control flow**. The most common conditional expression is the `if-else` statement. It's best illustrated with an example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 0\nif (a != 0) {\n  print(1/a)\n} else{\n  print(\"Can't divide by zero!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Can't divide by zero!\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nThe condition `a != 0` was evaluated to be `FALSE` (since `a` was assigned 0). So, the conditional went to the `else` statement and printed \"Can't divide by zero!\" to the console as we told it to. By contrast:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 4\nif (a != 0) {\n  print(1/a)\n} else{\n  print(\"Can't divide by zero!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.25\n```\n\n\n:::\n:::\n\n\n\n\n## Conditionals\n\nLet's incorporate conditionals into our `quadratic_solver` function from before. Remember that a quadratic equation has no real solutions if the **discriminant** $D$ is negative (because of the root in the \"midnight\" formula):\n\n$$D = b^2 - 4ac$$\n\n. . .\n\nSo far, when this is case, our function produces `NaN`s and a warning:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadratic_solver(2, 2, 2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in sqrt(b^2 - 4 * a * c): NaNs wurden erzeugt\nWarning in sqrt(b^2 - 4 * a * c): NaNs wurden erzeugt\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN NaN\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nLet's fix this by:\n\n-   Returning no solutions / NA if $D < 0$.\n-   Returning one solution if $D = 0$.\n-   Returning two solutions (as before) if $D > 0$.\n\n\n## Conditionals\n\nOne solution could be the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3-5|6-10|11-14|\"}\nquadratic_solver_new <- function(a, b, c){\n  D <- b^2 - 4*a*c\n  if(D < 0){\n    print(\"Discriminant is negative, no real solutions!\")\n    return(NA)\n  } else if(D > 0) {\n    print(\"Discriminant is positive, two real solutions!\")\n    sol_1 <- (-b + sqrt(D))/(2*a)\n    sol_2 <- (-b - sqrt(D))/(2*a)\n    return(c(sol_1, sol_2))\n  } else {\n    print(\"Discriminant is zero, one real solution!\")\n    sol <- -b/(2*a)\n    return(sol)\n  }\n}\n```\n:::\n\n\n\n. . .\n\n::::: columns\n::: {.column width=\"50%}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadratic_solver_new(2, 2, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Discriminant is negative, no real solutions!\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nquadratic_solver_new(3, -5, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Discriminant is positive, two real solutions!\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.4342585 0.2324081\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadratic_solver_new(1, 2, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Discriminant is zero, one real solution!\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1\n```\n\n\n:::\n:::\n\n\n:::\n:::::\n\n\n## Conditionals\n\n`if-else` statements like the ones we saw only work on a single logical. For a **vectorized** version, there is the very useful `ifelse` function: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(0, 2, 4, 6, 0, 8)\nifelse(a != 0, 1/a, NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]        NA 0.5000000 0.2500000 0.1666667        NA 0.1250000\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nThis function takes three arguments: a logical and two possible answers. If the logical is TRUE, the value in the second argument is returned and if FALSE, the value in the third argument is returned. When operating on vectors, `ifelse` takes the corresponding **elements** of the second or third argument.\n\nHere' another example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nifelse(x %% 2 == 0, \"even\", \"odd\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n```\n\n\n:::\n:::\n\n\n\nNote: `x %% 2` gives the remainder when dividing x by 2.\n\n\n## For-loops\n\nIn general, **loops** control flow structures that enable the repeated execution of a code block as long as a specified condition is met. This saves a lot of manual work and code duplication. We will discuss two types of loops: `for` loops and `while` loops.\n\n. . .\n\n`for` loops are used to **iterate** over items in a vector. The logic is \"for every item in this vector, do the following\". This logic is implemented in the following basic form:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(item in vector) {\n  perform_action\n}\n```\n:::\n\n\n\n. . .\n\nFollowing this notation, we can refer to the element of the `vector` in the current loop cycle with the name of `item`. In the first cycle, it will be the first element of the vector, in the second, it will be the second, and so on...\n\n## For-loops\n\nLet's see an example of a `for` loop that prints both solutions to the quadratic equation from before in a nice format:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsolutions <- quadratic_solver_new(3, -5, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Discriminant is positive, two real solutions!\"\n```\n\n\n:::\n\n```{.r .cell-code}\nn <- length(solutions)\n\nfor(i in 1:n){\n  print(paste0(\"Solution \", i, \": \", round(solutions[i], 3)))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Solution 1: 1.434\"\n[1] \"Solution 2: 0.232\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nNote that we do not have to loop through an integer vector, we can loop through any atomic vector or list. For example, we could loop through all the elements of the list `l1` from earlier and print it to the console only if it is a numeric vector:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(el in l1){\n  if(is.numeric(el)){\n    print(el)\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n[1] 2.3 5.9\n```\n\n\n:::\n:::\n\n\n\n\n## While-loops\n\nAnother type of loop is a `while` loop. It repeats a specified action as long as a certain condition is met. It has the following basic form:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhile(condition){\n  perform_action\n}\n```\n:::\n\n\n\n. . .\n\nNote that `for` and `while` loops are interchangeable in **every circumstance**, i.e. every `for` loop can be implemented as a `while` loop and vice versa. Usually, the choice between the two is a question of code readability and efficiency considerations. Compare the following two examples:\n\n::::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|4\"}\ni <- 1L\nwhile(i <= 3L){\n  print(i)\n  i <- i + 1L\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n```\n\n\n:::\n:::\n\n\n\nNote that the last step in the loop is crucial. Otherwise we loop infinitely!\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:3){\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n```\n\n\n:::\n:::\n\n\n:::\n:::::\n\n\n## Functionals\n\nIn R, a very commonly used alternative to loops is the use of **functionals**. Functionals are functions that take another function as an input and returns a vector as output. Common functionals we will have a look at are `lapply`, and `apply`. Let's start with `lapply`.\n\n. . .\n\n`lapply` requires as arguments an atomic vector or a list and a function that it should apply to each element of that atomic vector or list. Let's say we wanted to sort each vector in a list of vectors. We could do:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl2 <- list(sample(1:10), sample(1:20))\nl2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] 10  9  5  4  7  1  3  6  8  2\n\n[[2]]\n [1]  5 14 20  2 17  8  1 16 18 15  7 11 12  4 19 10  3 13  9  6\n```\n\n\n:::\n\n```{.r .cell-code}\nlapply(l2, sort)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n[[2]]\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n```\n\n\n:::\n:::\n\n\n\n\n## Functionals\nIn fact, we can pass named arguments that we would usually pass to the function to be applied directly to `lapply` instead:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(l2, sort, decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] 10  9  8  7  6  5  4  3  2  1\n\n[[2]]\n [1] 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nInstead of using `lapply` with a pre-existing (or user-defined) function, we can also create an inline function that exists only for the purpose of that `lapply` call. For example, we might want to square each vector in the list after sorting:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(l2, function(x) sort(x, decreasing = TRUE)^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] 100  81  64  49  36  25  16   9   4   1\n\n[[2]]\n [1] 400 361 324 289 256 225 196 169 144 121 100  81  64  49  36  25  16   9   4\n[20]   1\n```\n\n\n:::\n:::\n\n\n\nSuch functions are called **anonymous functions** as they do not have a name.\n\n\n\n## Functionals\n\nThe **matrix** equivalent of `lapply` is called `apply`. It can apply a given function to every row and / or every column of a matrix. Besides requiring the matrix and the function to be applied, it requires an indication of whether application should happen over **rows** (1) or **columns** (2). Consider the following example to compute the row and column sums of a matrix:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:9, 3, 3)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n\n\n:::\n\n```{.r .cell-code}\napply(m, 1, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 15 18\n```\n\n\n:::\n\n```{.r .cell-code}\napply(m, 2, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6 15 24\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nThe use of functionals like `lapply` and `apply` is usually preferable over loops because it pre-specifies what should happen with the result (e.g. `lapply` will always hold the results in a list).\n\n\n# Packages\n\n## Packages\n\n-   With the base installation, R comes with a lot of functionality already. However, statisticians and data scientists all over the world constantly come up with new methods and clever code to solve problems.\n-   To share this code, they create **R packages**: these include fundamental units of reproducible R code, including reusable R functions, the documentation that describes how to use them, and sample data.\n-   To make these packages available, the creators typically upload them to the **Comprehensive R Archive Network (CRAN)**.\n-   From there, any R user can download and install these packages and use them for their own workflows.\n\n## Packages\n\n-   As of 22nd February 2025, there are 22,100 R packages available for download on [CRAN](https://cran.r-project.org/web/packages/). Each of them has a unique name that we can use to obtain it.\n-   We will be working only with a select few of them.\n-   One of them will be **ggplot2**, which is one of the most popular R packages used for data visualization.\n-   As an R programmer, one typically finds packages that solve a given problem by googling the problem one is encountering. Chances are that someone else has had this problem before...\n\n. . .\n\nTo install a package, we call the function `install.packages` on the name of the package:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"ggplot2\")\n```\n:::\n\n\n\nThis downloads and installs the package on your computer. \n\n## Packages\n\nAs with any software, an R package only needs to be **installed** once.\n\n. . .\n\nAfter installation, we need to tell R to make the functions provided by this package available to us in our current R session. For this we call the function `library` on the name of the package:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n```\n:::\n\n\n\n-   Now, all data and functions offered by this package can be used. \n-   A package comes with a [reference manual](https://cran.r-project.org/web/packages/ggplot2/ggplot2.pdf) and often additional documentation in the form of so called package [**vignettes**](https://cran.r-project.org/web/packages/ggplot2/vignettes/ggplot2.html).\n-   This helps the user understand how to use the functions in the package.\n-   Additionally, documentation on individual functions is always available through the help of the `?` operator.\n\n\n## Packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mpg, aes(displ, hwy, colour = class)) + \n  geom_point() + \n  xlab(\"Engine Displacement\") + ylab(\"MPG\") + \n  theme(legend.text = element_text(size=14), axis.text = element_text(size=14), axis.title = element_text(size=14))\n```\n\n::: {.cell-output-display}\n![](02_The_Essentials_of_R_Programming_files/figure-revealjs/unnamed-chunk-100-1.png){width=1536}\n:::\n:::\n",
    "supporting": [
      "02_The_Essentials_of_R_Programming_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}